<!-- tile_generator.html — single file, no build step -->
<!DOCTYPE html>
<meta charset="utf-8" />
<title>SDF Tile Generator</title>

<style>
  body  { margin:0; height:100vh; display:grid; place-content:center;
          background:#222; color:#eee; font:14px sans-serif; }
  canvas{ border:1px solid #444; image-rendering:pixelated; }
  #ui   { display:flex; flex-direction:column; gap:.75rem; align-items:center; }
</style>

<div id="ui">
  <canvas id="gl" width="1024" height="1024"></canvas>
  <button id="save">Download PNG</button>
</div>

<!-- ── Vertex shader ── -->
<script type="x-shader/x-vertex" id="vs">
attribute vec2 pos;
varying   vec2 uv;
void main(){
  uv = pos * .5 + .5;
  gl_Position = vec4(pos, 0.0, 1.0);
}
</script>

<!-- ── Fragment shader ── -->
<script type="x-shader/x-fragment" id="fs">
  precision highp float;
varying vec2 uv;

/* geometry measured from bg4.png */
const float CENTER_SZ      = 0.213;   // central square half-width
const float CORNER_SZ      = 0.107;   // quarter square half-width
const float CENTER_RADIUS  = 0.033;   // rounding on big square
const float INNER_RADIUS   = 0.048;   // rounding on *inner* corner
const float SMOOTH_K       = 0.060;   // single-diagonal bridge
const float ENCODE_SCALE   = 32.0;    // min→0  max→1  (keeps thresholds)

/* helpers ------------------------------------------------------------*/
float sdRoundBox(vec2 p, vec2 b, float r){
    vec2 q = abs(p) - b + r;
    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;
}
float smin(float a, float b, float k){
    float h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}
/* quarter square with rounding only on inner corner */
float qSquare(vec2 p, vec2 orient){
    vec2 lp = p * orient;                       // inner corner → (+,+)
    float r = (lp.x > 0.0 && lp.y > 0.0) ? INNER_RADIUS : 0.0;
    return sdRoundBox(lp, vec2(CORNER_SZ), r);
}

void main(){
    vec2 p = uv - 0.5;                          // centre coords

    /* 1️⃣ central square (white in your plot) */
    float d = sdRoundBox(p, vec2(CENTER_SZ), CENTER_RADIUS);

    /* 2️⃣ add only two quarter squares for ONE diagonal bridge */
    d = smin(d, qSquare(p + vec2(-0.5 + CORNER_SZ,
                                 -0.5 + CORNER_SZ), vec2( 1.0,  1.0)), SMOOTH_K); // BL
    d = smin(d, qSquare(p + vec2( 0.5 - CORNER_SZ,
                                  0.5 - CORNER_SZ), vec2(-1.0, -1.0)), SMOOTH_K); // TR
    /* top-left and bottom-right quarters are *not* merged => stay black */

    /* 3️⃣ encode SDF  (0.5 = surface)  so thresholds 0/1 wipe clean */
    float sdf = clamp(d * ENCODE_SCALE + 0.5, 0.0, 1.0);
    gl_FragColor = vec4(vec3(sdf), 1.0);
}
  </script>
  

<!-- ── JavaScript ── -->
<script>
const canvasEl = document.getElementById('gl');
const gl = canvasEl.getContext('webgl', { preserveDrawingBuffer: true });

/* compile & link */
function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(s));
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,
                              document.getElementById('vs').textContent));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER,
                              document.getElementById('fs').textContent));
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
  throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

/* fullscreen triangle */
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
const loc = gl.getAttribLocation(prog, 'pos');
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

/* draw once */
gl.viewport(0, 0, canvasEl.width, canvasEl.height);
gl.drawArrays(gl.TRIANGLES, 0, 3);

/* Download PNG */
document.getElementById('save').addEventListener('click', () => {
  canvasEl.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a   = document.createElement('a');
    a.href = url; a.download = 'my_tile.png'; a.click();
    URL.revokeObjectURL(url);
  }, 'image/png');
});
</script>
